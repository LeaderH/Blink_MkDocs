{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BLINK's documentation # BLINK (Binary LINt Kit) is an Android quality/vunlnerability assessment framework. It supports various Android application analyzing workflows without the need for application's source code - that is, BLINK directly takes APKs as input. To ensure a stable source of detecting rules and examples, BLINK also boosts similar rule definition style of that from Android Lint , an official Android source code linter. You can kown more about BLINK with how to install and manipulate . BLINK workflow # BLINK consists of two major processing modules, a metaobject(Apkinfo), and numerous customizable detecting rules(Detectors). Decompiling module # Leveraging slightly modified Androgurad core, BLINK decompiles and extracts every interesting resources within an APK and maps each resource into individual python objects. BLINK also further analyze and maintain every caller-callee, field read-field write relationships with cross reference entries, which is crucial for later needs of dataflow analysis. Analyzing module # A RuleManager is responsible for govening the availability of the Detectors as well as loading them in order into analyzing module. Detectors access resource or information in target APK via implementing corresponding ScannerInterfaces. By following Request, Callback, Report design patterns, BLINK can accommodate various workflow without any risk of confliction.","title":"About"},{"location":"#welcome-to-blinks-documentation","text":"BLINK (Binary LINt Kit) is an Android quality/vunlnerability assessment framework. It supports various Android application analyzing workflows without the need for application's source code - that is, BLINK directly takes APKs as input. To ensure a stable source of detecting rules and examples, BLINK also boosts similar rule definition style of that from Android Lint , an official Android source code linter. You can kown more about BLINK with how to install and manipulate .","title":"Welcome to BLINK's documentation"},{"location":"#blink-workflow","text":"BLINK consists of two major processing modules, a metaobject(Apkinfo), and numerous customizable detecting rules(Detectors).","title":"BLINK workflow"},{"location":"#decompiling-module","text":"Leveraging slightly modified Androgurad core, BLINK decompiles and extracts every interesting resources within an APK and maps each resource into individual python objects. BLINK also further analyze and maintain every caller-callee, field read-field write relationships with cross reference entries, which is crucial for later needs of dataflow analysis.","title":"Decompiling module"},{"location":"#analyzing-module","text":"A RuleManager is responsible for govening the availability of the Detectors as well as loading them in order into analyzing module. Detectors access resource or information in target APK via implementing corresponding ScannerInterfaces. By following Request, Callback, Report design patterns, BLINK can accommodate various workflow without any risk of confliction.","title":"Analyzing module"},{"location":"apkinfo/","text":"Apkinfo # Apkinfo is the core object of an instance of analysis on single target APK; it not only is in charge of manipulating all the communication between test rules defined in the evaluation module and fundamental elements gathered in the previous decompile module, but also has to collect and produce final reports. category sample methods info metadata pkg_name, file_size, versionCode, md5,permissions\u2026 APK\u2019s basic information resource get_all_strings, get_files, get_xml, find_methods\u2026 locating target resources and objects auxiliary isMemberInClass, methodMatches, parametersMatch\u2026 helper methods for test rules reporting set_reportor, report collect reports from test rules .property / method parameters description .androguard_objects fallback to androguard analysis object .all_files .reportor report collecting object .filename apk filename .filesize .dex_filesize .md5 .permissions .minSdk .targetSdk .versionName .versionCode .packagename .all_files iterate all files .all_methods iterate all methods get_file_read file_name get raw file get_files iterate all files get_file file_name get FileObject get_xml xml_filename get_android_manifest_xml get_android_resources ARSCParser get_res_value ref_id resolve resource reference id (format @...) get_all_strings find_classes class_name, no_external, filter_regex find classes with class_name, can apply filters or exclude Android built-in APIs find_methods class_name,method_name,descriptor,filter_regex find methods matching method_name, member class_name, and descriptor (parameter types) find_references class_name,ref_name,ref_type find a static field with specified name, type and member class methodMatches method, class_name, allow inherit, parameter_types check whether a method is a member of a class or subclass with class_name (allow inherit) and takes certain types of parameters parametersMatch method, parameter_types check whether a method takes certain types of parameters isMemberInClass method_field, class_name check whether a field or method is a member of a class with class_name isMemberSubClassOf method_field, class_name, allow_inherit check whether a field or method is a member of a subclass(allow inherit) with class_name set_reporter reporter report issue, method, message, location report an issue record","title":"Apkinfo"},{"location":"apkinfo/#apkinfo","text":"Apkinfo is the core object of an instance of analysis on single target APK; it not only is in charge of manipulating all the communication between test rules defined in the evaluation module and fundamental elements gathered in the previous decompile module, but also has to collect and produce final reports. category sample methods info metadata pkg_name, file_size, versionCode, md5,permissions\u2026 APK\u2019s basic information resource get_all_strings, get_files, get_xml, find_methods\u2026 locating target resources and objects auxiliary isMemberInClass, methodMatches, parametersMatch\u2026 helper methods for test rules reporting set_reportor, report collect reports from test rules .property / method parameters description .androguard_objects fallback to androguard analysis object .all_files .reportor report collecting object .filename apk filename .filesize .dex_filesize .md5 .permissions .minSdk .targetSdk .versionName .versionCode .packagename .all_files iterate all files .all_methods iterate all methods get_file_read file_name get raw file get_files iterate all files get_file file_name get FileObject get_xml xml_filename get_android_manifest_xml get_android_resources ARSCParser get_res_value ref_id resolve resource reference id (format @...) get_all_strings find_classes class_name, no_external, filter_regex find classes with class_name, can apply filters or exclude Android built-in APIs find_methods class_name,method_name,descriptor,filter_regex find methods matching method_name, member class_name, and descriptor (parameter types) find_references class_name,ref_name,ref_type find a static field with specified name, type and member class methodMatches method, class_name, allow inherit, parameter_types check whether a method is a member of a class or subclass with class_name (allow inherit) and takes certain types of parameters parametersMatch method, parameter_types check whether a method takes certain types of parameters isMemberInClass method_field, class_name check whether a field or method is a member of a class with class_name isMemberSubClassOf method_field, class_name, allow_inherit check whether a field or method is a member of a subclass(allow inherit) with class_name set_reporter reporter report issue, method, message, location report an issue record","title":"Apkinfo"},{"location":"detector/","text":"Detector Implementation # To implement a custom Detector that operates on BLINK, there envolves three steps as follow: BLINK boost straightforward detecting rule conversion from Android Lint . We can get access to Android Lint's Detector Implementation via ASOP . Most of the checks used to be written in Java and converted to Kotlin gradually. However, regardless of the programing language they are in, they share the same disign logic and process. Let's take a look at one of rule of Android Lint and mark its critical sections: And here is how a converted Detector rule would be like in BLINK:","title":"Detector"},{"location":"detector/#detector-implementation","text":"To implement a custom Detector that operates on BLINK, there envolves three steps as follow: BLINK boost straightforward detecting rule conversion from Android Lint . We can get access to Android Lint's Detector Implementation via ASOP . Most of the checks used to be written in Java and converted to Kotlin gradually. However, regardless of the programing language they are in, they share the same disign logic and process. Let's take a look at one of rule of Android Lint and mark its critical sections: And here is how a converted Detector rule would be like in BLINK:","title":"Detector Implementation"},{"location":"installation/","text":"Installation # python3 (python3.9) install dependecies, we highly recommand using pipenv or venv to run the tool in a controlled envirionment pipenv pipenv install --python 3.9 pipenv shell exit virtual environment with exit mongodb (optional) cp db_config.py.example db_config.py vim db_config.py specify db_config.py for your db connection db_config.py.example # ############################## # MongoDB Config ############################## \"\"\"Remote MongoDB\"\"\" # If remote sever address is provided, # the following local setting is ignored MONGODB_REMOTE = None \"\"\"Local/ host MongoDB \"\"\" MONGODB_HOST = \"localhost\" MONGODB_PORT = 27017 \"\"\"Database Name\"\"\" MONGODB_DBNAME = \"Blink\" ############################## # MongoDB Collections Setting ############################## COLLECTION_RESULT = \"AppInfo\" COLLECTION_RULES = \"RuleInfo\" User without the privilege to install python3.9 # getting standalone python build get python3.9 from standalone builds (cpython3.9...install_only.tar.gz) extracting and aliasing tar -xvf *install_only.tar.gz alias python3.9=\"python\\bin\\python3.9\" pipenv python3.9 -m pipenv install --python 3.9 python3.9 -m pipenv shell","title":"Installation"},{"location":"installation/#installation","text":"python3 (python3.9) install dependecies, we highly recommand using pipenv or venv to run the tool in a controlled envirionment pipenv pipenv install --python 3.9 pipenv shell exit virtual environment with exit mongodb (optional) cp db_config.py.example db_config.py vim db_config.py specify db_config.py for your db connection","title":"Installation"},{"location":"installation/#db_configpyexample","text":"############################## # MongoDB Config ############################## \"\"\"Remote MongoDB\"\"\" # If remote sever address is provided, # the following local setting is ignored MONGODB_REMOTE = None \"\"\"Local/ host MongoDB \"\"\" MONGODB_HOST = \"localhost\" MONGODB_PORT = 27017 \"\"\"Database Name\"\"\" MONGODB_DBNAME = \"Blink\" ############################## # MongoDB Collections Setting ############################## COLLECTION_RESULT = \"AppInfo\" COLLECTION_RULES = \"RuleInfo\"","title":"db_config.py.example"},{"location":"installation/#user-without-the-privilege-to-install-python39","text":"getting standalone python build get python3.9 from standalone builds (cpython3.9...install_only.tar.gz) extracting and aliasing tar -xvf *install_only.tar.gz alias python3.9=\"python\\bin\\python3.9\" pipenv python3.9 -m pipenv install --python 3.9 python3.9 -m pipenv shell","title":"User without the privilege to install python3.9"},{"location":"scanner/","text":"Scanner Interfaces # Scanner Interfaces are predefined analysis workflow with sets of query and call back methods to be overriden/implemented by Detectors. How do ScannerInterfaces works? # The main logic of ScannerInterface are defined within RuleManager(blink.Evaluate.rule_manager.py) A RuleManager will go through following steps when evaluting a Detector implementing a ScannerInterface: load the detector class with importlib (line 60) check if a class implement certain ScannerInterface via class's getImplementationSequence() method, the method needs to be predefined by ScannerInterfaces for returning itself at minimum. The method can also be overriden when a Detector implements multiple ScannerInterfaces and need to specify processing order. (line 139) rule_manager.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def run_single ( self , rule_cls : BaseScanner ): self . runCommonBefore ( rule_cls ) for implement in rule_cls . getImplementationSequence (): try : if implement == JavaScanner : self . runJavaRule ( rule_cls ) elif implement == ResourcesScanner : self . runResourceRule ( rule_cls ) elif implement == OtherFileScanner : self . runOtherFileRule ( rule_cls ) elif implement == XmlScanner : self . runXmlRule ( rule_cls ) else : raise NotImplementedError ( str ( f 'Scanner: { implement } unhandled' )) except Exception as e : tqdm . write ( traceback . format_exc ()) tqdm . write ( \"continue next...\" ) continue finally : pass define scanning process For example, the following is the code snippet within runJavaRule where(line 170) where we define the procedure and sequence of methods for accessing information from Apkinfo. Gather target methods' name via Detectors' getApplicableMethodNames() Locating target with APIs of Apkinfo, like .all_methods / find_methods() Retrieving MethodInstances (context sensitive objects) from MethodObjects Propagate the MethodInstances back to Detectors by invoking their call back visitMethodCall() rule_manager.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 if rule_cls . getApplicableMethodNames (): applicable = rule_cls . getApplicableMethodNames () if type ( applicable ) == tuple and applicable [ 0 ] == ALL_METHOD : filter_func = applicable [ 1 ] for method in self . apkinfo . all_methods : if not filter_func ( method ): continue for instance in method . getMethodInstances ( max_depth = MAX_METHODINSTANCE_TRACE_DEPTH , filter_regex = FILTER_CLASS_REGEXS ): rule_cls . visitMethodCall ( self . apkinfo , instance ) del instance del method else : for target_method in applicable : for method in self . apkinfo . find_methods ( method_name = target_method , filter_regex = FILTER_CLASS_REGEXS ): for instance in method . getMethodInstances ( max_depth = MAX_METHODINSTANCE_TRACE_DEPTH , filter_regex = FILTER_CLASS_REGEXS ): rule_cls . visitMethodCall ( self . apkinfo , instance ) del instance del method Another example is the implementation of XmlScanner in method runXmlRule. Gather target xmls' filename via Detectors' getApplicableXmlFiles() Propagate the the xml document with callback visitDocument() Gather target xml Element with element name via Detectors' getApplicableElements() Propagate the the xml element with callback visitElement() Gather target xml Attributes with Attributes name via Detectors' getApplicableAttributes() Propagate the the xml element with callback visitAttribute() rule_manager.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def runXmlRule ( self , rule_cls : XmlScanner ): file_scope = rule_cls . getApplicableXmlFiles () # skip searching part if we only consider AndroidManifest if len ( file_scope ) == 1 and file_scope [ 0 ] == Scope . MANIFEST : xmlFiles = [ self . apkinfo . get_android_manifest_xml ()] else : xmlFiles = self . apkinfo . get_scoped_files ( file_scope , rule_cls . appliesTo ) for xmlFile in xmlFiles : if xmlFile is None : continue rule_cls . visitDocument ( self . apkinfo , xmlFile ) applicable = rule_cls . getApplicableElements () if len ( applicable ) == 0 : if len ( rule_cls . getApplicableAttributes ()) > 0 : for element in xmlFile . findall ( \".//\" ): #rule_cls.visitElement(self.apkinfo, element) for attr in rule_cls . getApplicableAttributes (): for attr_node in element . getLocalAttributeNodes ( attr ): rule_cls . visitAttribute ( self . apkinfo , attr_node ) del attr_node else : for element_tag in applicable : for element in xmlFile . getElementsByTagName ( element_tag ): rule_cls . visitElement ( self . apkinfo , element ) for attr in rule_cls . getApplicableAttributes (): for attr_node in element . getLocalAttributeNodes ( attr ): rule_cls . visitAttribute ( self . apkinfo , attr_node ) del attr_node A Detector implementing above ScannerInterface would have communication sequence show as follows: BaseScanner # query / callback parameters description getImplementationSequence ensures checking order getDeclaredIssues commonBefore apkinfo the highest priority check commonAfter apkinfo the lowest priority check JavaScanner(BaseScanner) # query / callback parameters description getApplicableMethodNames getApplicableConstructorTypes getApplicableReferenceNames reference to static fields getApplicableSuperClasses visitMethodCall apkinfo, MethodInstance visitConstructor apkinfo, MethodInstance visitReferenceRead apkinfo, FieldInstance static fields visitReferenceWrite visitClass apkinfo, ClassObject otherAnalysis apkinfo general test over apkinfo ResourceScanner(BaseScanner) # query / callback parameters description checkResource apkinfo, ARSCParser overall resource files and R.java ID look up OtherFileScanner(BaseScanner) # query / callback parameters description getApplicableFiles file type appliesTo filename filter filename visitFile apkinfo, File XmlScanner(BaseScanner) # query / callback parameters description getApplicableXmlFiles res xml, androidmanifest appliesTo filter filename getApplicableElement getApplicableAttribute visitElement apkinfo, Element visitAttribute apkinfo, Attr","title":"Scanner"},{"location":"scanner/#scanner-interfaces","text":"Scanner Interfaces are predefined analysis workflow with sets of query and call back methods to be overriden/implemented by Detectors.","title":"Scanner Interfaces"},{"location":"scanner/#how-do-scannerinterfaces-works","text":"The main logic of ScannerInterface are defined within RuleManager(blink.Evaluate.rule_manager.py) A RuleManager will go through following steps when evaluting a Detector implementing a ScannerInterface: load the detector class with importlib (line 60) check if a class implement certain ScannerInterface via class's getImplementationSequence() method, the method needs to be predefined by ScannerInterfaces for returning itself at minimum. The method can also be overriden when a Detector implements multiple ScannerInterfaces and need to specify processing order. (line 139) rule_manager.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def run_single ( self , rule_cls : BaseScanner ): self . runCommonBefore ( rule_cls ) for implement in rule_cls . getImplementationSequence (): try : if implement == JavaScanner : self . runJavaRule ( rule_cls ) elif implement == ResourcesScanner : self . runResourceRule ( rule_cls ) elif implement == OtherFileScanner : self . runOtherFileRule ( rule_cls ) elif implement == XmlScanner : self . runXmlRule ( rule_cls ) else : raise NotImplementedError ( str ( f 'Scanner: { implement } unhandled' )) except Exception as e : tqdm . write ( traceback . format_exc ()) tqdm . write ( \"continue next...\" ) continue finally : pass define scanning process For example, the following is the code snippet within runJavaRule where(line 170) where we define the procedure and sequence of methods for accessing information from Apkinfo. Gather target methods' name via Detectors' getApplicableMethodNames() Locating target with APIs of Apkinfo, like .all_methods / find_methods() Retrieving MethodInstances (context sensitive objects) from MethodObjects Propagate the MethodInstances back to Detectors by invoking their call back visitMethodCall() rule_manager.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 if rule_cls . getApplicableMethodNames (): applicable = rule_cls . getApplicableMethodNames () if type ( applicable ) == tuple and applicable [ 0 ] == ALL_METHOD : filter_func = applicable [ 1 ] for method in self . apkinfo . all_methods : if not filter_func ( method ): continue for instance in method . getMethodInstances ( max_depth = MAX_METHODINSTANCE_TRACE_DEPTH , filter_regex = FILTER_CLASS_REGEXS ): rule_cls . visitMethodCall ( self . apkinfo , instance ) del instance del method else : for target_method in applicable : for method in self . apkinfo . find_methods ( method_name = target_method , filter_regex = FILTER_CLASS_REGEXS ): for instance in method . getMethodInstances ( max_depth = MAX_METHODINSTANCE_TRACE_DEPTH , filter_regex = FILTER_CLASS_REGEXS ): rule_cls . visitMethodCall ( self . apkinfo , instance ) del instance del method Another example is the implementation of XmlScanner in method runXmlRule. Gather target xmls' filename via Detectors' getApplicableXmlFiles() Propagate the the xml document with callback visitDocument() Gather target xml Element with element name via Detectors' getApplicableElements() Propagate the the xml element with callback visitElement() Gather target xml Attributes with Attributes name via Detectors' getApplicableAttributes() Propagate the the xml element with callback visitAttribute() rule_manager.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def runXmlRule ( self , rule_cls : XmlScanner ): file_scope = rule_cls . getApplicableXmlFiles () # skip searching part if we only consider AndroidManifest if len ( file_scope ) == 1 and file_scope [ 0 ] == Scope . MANIFEST : xmlFiles = [ self . apkinfo . get_android_manifest_xml ()] else : xmlFiles = self . apkinfo . get_scoped_files ( file_scope , rule_cls . appliesTo ) for xmlFile in xmlFiles : if xmlFile is None : continue rule_cls . visitDocument ( self . apkinfo , xmlFile ) applicable = rule_cls . getApplicableElements () if len ( applicable ) == 0 : if len ( rule_cls . getApplicableAttributes ()) > 0 : for element in xmlFile . findall ( \".//\" ): #rule_cls.visitElement(self.apkinfo, element) for attr in rule_cls . getApplicableAttributes (): for attr_node in element . getLocalAttributeNodes ( attr ): rule_cls . visitAttribute ( self . apkinfo , attr_node ) del attr_node else : for element_tag in applicable : for element in xmlFile . getElementsByTagName ( element_tag ): rule_cls . visitElement ( self . apkinfo , element ) for attr in rule_cls . getApplicableAttributes (): for attr_node in element . getLocalAttributeNodes ( attr ): rule_cls . visitAttribute ( self . apkinfo , attr_node ) del attr_node A Detector implementing above ScannerInterface would have communication sequence show as follows:","title":"How do ScannerInterfaces works?"},{"location":"scanner/#basescanner","text":"query / callback parameters description getImplementationSequence ensures checking order getDeclaredIssues commonBefore apkinfo the highest priority check commonAfter apkinfo the lowest priority check","title":"BaseScanner"},{"location":"scanner/#javascannerbasescanner","text":"query / callback parameters description getApplicableMethodNames getApplicableConstructorTypes getApplicableReferenceNames reference to static fields getApplicableSuperClasses visitMethodCall apkinfo, MethodInstance visitConstructor apkinfo, MethodInstance visitReferenceRead apkinfo, FieldInstance static fields visitReferenceWrite visitClass apkinfo, ClassObject otherAnalysis apkinfo general test over apkinfo","title":"JavaScanner(BaseScanner)"},{"location":"scanner/#resourcescannerbasescanner","text":"query / callback parameters description checkResource apkinfo, ARSCParser overall resource files and R.java ID look up","title":"ResourceScanner(BaseScanner)"},{"location":"scanner/#otherfilescannerbasescanner","text":"query / callback parameters description getApplicableFiles file type appliesTo filename filter filename visitFile apkinfo, File","title":"OtherFileScanner(BaseScanner)"},{"location":"scanner/#xmlscannerbasescanner","text":"query / callback parameters description getApplicableXmlFiles res xml, androidmanifest appliesTo filter filename getApplicableElement getApplicableAttribute visitElement apkinfo, Element visitAttribute apkinfo, Attr","title":"XmlScanner(BaseScanner)"},{"location":"usage/","text":"Usage # Command Line Entry point # blink.cli Entry point for an analysis task, one can specify input target APKs and ruleset directory, output types, format, and several analysis parameters. Example usage: python -m blink.cli -i sample.apk -o csv -o txt -s -t -db -T test output csv, txt and show to console time the analysis critical steps store result in database assign a tag to mark this analysis run Usage: python -m blink.cli [OPTIONS] Blink: Andoird binary lint kit Options: -i, --input PATH input APK File/ Folder(single layer) [required] -d, --outdir DIRECTORY Analysis Report Output Directory -o, --output-type [txt|xml|csv] Output file type -r, --rules DIRECTORY Rules folder need to be checked -s, --show Show result to console -v, --verbose Show detailed result(imply show) -db, --database Store result to database(need to set db_config) -T, --analyze-tag TEXT Analysis tag mark this round of analysis(also used as output dirname) -t, --timed Time critical steps -p, --prediction Riskware Predicton(CICMalDroid2020) -seq, --sequential Analyze target sequentially (disable multiprocessing) --timeout INTEGER Timeout value (in sec) -n, --process-cnt INTEGER Mutiprocess core count --version --help Show this message and exit. Rule Management # blink.config Manage availabilities of rules(Detectors) in a ruleset, support regular expression syntax. Example usage: python -m blink.config -e \"Allow*\" blink/Rules eable rule with regex wildcard Usage: python -m blink.config [OPTIONS] [RULE_DIR] If Enable/Disable all is set, single operations will be ignored Operation order: enable -> disable :param [RULE_DIR]: default to 'blink/Rules' Options: -e, --enable TEXT Enable rule with name match regular expression -d, --disable TEXT Disable rule with name match regular expression -l, --show [main op] List/Show rules -ea [main op] Enable all -da [main op] Disable all --help Show this message and exit. Report format # Result (single apk) # xml # <analysis target=\"lintTest1.apk\" total=\"78\"> <report rule_file=\"C2dmDetector\" count=\"1\" target=\"lintTest1.apk\"> <issue id=\"UsingC2DM\"...> <instance location=\"...\" message=\"...\"/> </issue> </report> </analysis> txt # [C2dmDetector] - 1 > UsingC2DM: 1 - AndroidManifest.xml@4->android:name * The C2DM library does not work on Android P or newer devices; you should migrate to Firebase Cloud Messaging to ensure reliable message delivery mongoDB document # { _id:62e21496af32c00c62d3107e, _AnalysisTag:\"072822_124550\", _APK:\"com.blink.test.minApi16.debug\", _VersionCode:\"1\", _MD5:\"5b30bf0f130b5dff7cfd59c553612f33\", AcceptsUserCertificates:1, AddJavascriptInterface:11, AllowAllHostnameVerifier:2, AllowBackup:0, AuthLeak:1, ... } Result (multiple apk) # csv # _APK _VersionCode _MD5 AcceptsUserCertificates AddJavascriptInterface xxx.apk 1.0 xxxx 0 1 yyy.apk 1.3 xxxx 1 1 zzz.apk 2.0 xxxx 1 0 Database lookup # blink.db_lookup Auxiliary functions interacting with BLINK's results stored with mongoDB. Example usage: python -m blink.db_lookup rule_detail -i AllowBackup - lookup details about a rule python -m blink.db_lookup result -i sample.apk -T tag - lookup result of a apk - provide analyze_tag to filter result of specific run python -m blink.db_lookup rule_result -i AllowBackup - lookup apks that triggered a specific rule Usage: python -m blink.db_lookup [OPTIONS] {rule_detail|result|rule_result} Manipulate MongoDB results Options: -i, --identity TEXT Rule Id or packageName -T, --analyze-tag TEXT Analysis tag mark this round of analysis --apk-md5 TEXT APK's md5 --help Show this message and exit. Output # rule_detail # ID: AllowBackup Category: SECURITY Severity: WARNING Priority: 3 Description: The allowBackup attribute determines if an application's data can be backed up and restored. It is documented at http://developer.android.com/reference/android/R.attr.html#allowBackup ... result # PackageName: com.blink.test.minApi16.debug VesionCode: 1 MD5: 5b30bf0f130b5dff7cfd59c553612f33 AnalyzeTag: 072822_124550 [AcceptsUserCertificates]: 1 [AddJavascriptInterface]: 11 [AllowAllHostnameVerifier]: 2 ... [WorldWriteableFiles]: 0 Appearence: 22, Total: 79 rule_result # RuleID [AllowBackup] <Tag: 072822_122556> at.tacticaldevc.panictrigger: 1 com.pierreduchemin.smsforward: 1 com.saverio.pdfviewer: 1 com.wesaphzt.privatelocation: 1 de.chagemann.regexcrossword: 1 nl.patrickkostjens.kandroid: 1 org.mozilla.klar: 1 sh.ftp.rocketninelabs.meditationassistant.opensource: 1 Appearence: 8, Total: 8 RandomFileSelector # blink.Util.RandomFileSelector Auxiliary fuction for randomly select given number of target files and rename them. Example usage: python -m blink.Util.RandomFileSelector -f DataSet/ -o Samples/ -n 10 -r --prefix case - randomly pick 10 test case from /DataSet to /Samples and rename as case[\\d] Usage: python -m blink.Util.RandomFileSelector [OPTIONS] Randomly chose and copy files in a folder. Options: -f, --folder DIRECTORY Target folder [required] -o, --output DIRECTORY Output folder [required] -n, --number INTEGER Amount [required] --prefix TEXT Rename copied file with prefix [default: case] -r, --rename Rename copied file --help Show this message and exit.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#command-line-entry-point","text":"blink.cli Entry point for an analysis task, one can specify input target APKs and ruleset directory, output types, format, and several analysis parameters. Example usage: python -m blink.cli -i sample.apk -o csv -o txt -s -t -db -T test output csv, txt and show to console time the analysis critical steps store result in database assign a tag to mark this analysis run Usage: python -m blink.cli [OPTIONS] Blink: Andoird binary lint kit Options: -i, --input PATH input APK File/ Folder(single layer) [required] -d, --outdir DIRECTORY Analysis Report Output Directory -o, --output-type [txt|xml|csv] Output file type -r, --rules DIRECTORY Rules folder need to be checked -s, --show Show result to console -v, --verbose Show detailed result(imply show) -db, --database Store result to database(need to set db_config) -T, --analyze-tag TEXT Analysis tag mark this round of analysis(also used as output dirname) -t, --timed Time critical steps -p, --prediction Riskware Predicton(CICMalDroid2020) -seq, --sequential Analyze target sequentially (disable multiprocessing) --timeout INTEGER Timeout value (in sec) -n, --process-cnt INTEGER Mutiprocess core count --version --help Show this message and exit.","title":"Command Line Entry point"},{"location":"usage/#rule-management","text":"blink.config Manage availabilities of rules(Detectors) in a ruleset, support regular expression syntax. Example usage: python -m blink.config -e \"Allow*\" blink/Rules eable rule with regex wildcard Usage: python -m blink.config [OPTIONS] [RULE_DIR] If Enable/Disable all is set, single operations will be ignored Operation order: enable -> disable :param [RULE_DIR]: default to 'blink/Rules' Options: -e, --enable TEXT Enable rule with name match regular expression -d, --disable TEXT Disable rule with name match regular expression -l, --show [main op] List/Show rules -ea [main op] Enable all -da [main op] Disable all --help Show this message and exit.","title":"Rule Management"},{"location":"usage/#report-format","text":"","title":"Report format"},{"location":"usage/#result-single-apk","text":"","title":"Result (single apk)"},{"location":"usage/#xml","text":"<analysis target=\"lintTest1.apk\" total=\"78\"> <report rule_file=\"C2dmDetector\" count=\"1\" target=\"lintTest1.apk\"> <issue id=\"UsingC2DM\"...> <instance location=\"...\" message=\"...\"/> </issue> </report> </analysis>","title":"xml"},{"location":"usage/#txt","text":"[C2dmDetector] - 1 > UsingC2DM: 1 - AndroidManifest.xml@4->android:name * The C2DM library does not work on Android P or newer devices; you should migrate to Firebase Cloud Messaging to ensure reliable message delivery","title":"txt"},{"location":"usage/#mongodb-document","text":"{ _id:62e21496af32c00c62d3107e, _AnalysisTag:\"072822_124550\", _APK:\"com.blink.test.minApi16.debug\", _VersionCode:\"1\", _MD5:\"5b30bf0f130b5dff7cfd59c553612f33\", AcceptsUserCertificates:1, AddJavascriptInterface:11, AllowAllHostnameVerifier:2, AllowBackup:0, AuthLeak:1, ... }","title":"mongoDB document"},{"location":"usage/#result-multiple-apk","text":"","title":"Result (multiple apk)"},{"location":"usage/#csv","text":"_APK _VersionCode _MD5 AcceptsUserCertificates AddJavascriptInterface xxx.apk 1.0 xxxx 0 1 yyy.apk 1.3 xxxx 1 1 zzz.apk 2.0 xxxx 1 0","title":"csv"},{"location":"usage/#database-lookup","text":"blink.db_lookup Auxiliary functions interacting with BLINK's results stored with mongoDB. Example usage: python -m blink.db_lookup rule_detail -i AllowBackup - lookup details about a rule python -m blink.db_lookup result -i sample.apk -T tag - lookup result of a apk - provide analyze_tag to filter result of specific run python -m blink.db_lookup rule_result -i AllowBackup - lookup apks that triggered a specific rule Usage: python -m blink.db_lookup [OPTIONS] {rule_detail|result|rule_result} Manipulate MongoDB results Options: -i, --identity TEXT Rule Id or packageName -T, --analyze-tag TEXT Analysis tag mark this round of analysis --apk-md5 TEXT APK's md5 --help Show this message and exit.","title":"Database lookup"},{"location":"usage/#output","text":"","title":"Output"},{"location":"usage/#rule_detail","text":"ID: AllowBackup Category: SECURITY Severity: WARNING Priority: 3 Description: The allowBackup attribute determines if an application's data can be backed up and restored. It is documented at http://developer.android.com/reference/android/R.attr.html#allowBackup ...","title":"rule_detail"},{"location":"usage/#result","text":"PackageName: com.blink.test.minApi16.debug VesionCode: 1 MD5: 5b30bf0f130b5dff7cfd59c553612f33 AnalyzeTag: 072822_124550 [AcceptsUserCertificates]: 1 [AddJavascriptInterface]: 11 [AllowAllHostnameVerifier]: 2 ... [WorldWriteableFiles]: 0 Appearence: 22, Total: 79","title":"result"},{"location":"usage/#rule_result","text":"RuleID [AllowBackup] <Tag: 072822_122556> at.tacticaldevc.panictrigger: 1 com.pierreduchemin.smsforward: 1 com.saverio.pdfviewer: 1 com.wesaphzt.privatelocation: 1 de.chagemann.regexcrossword: 1 nl.patrickkostjens.kandroid: 1 org.mozilla.klar: 1 sh.ftp.rocketninelabs.meditationassistant.opensource: 1 Appearence: 8, Total: 8","title":"rule_result"},{"location":"usage/#randomfileselector","text":"blink.Util.RandomFileSelector Auxiliary fuction for randomly select given number of target files and rename them. Example usage: python -m blink.Util.RandomFileSelector -f DataSet/ -o Samples/ -n 10 -r --prefix case - randomly pick 10 test case from /DataSet to /Samples and rename as case[\\d] Usage: python -m blink.Util.RandomFileSelector [OPTIONS] Randomly chose and copy files in a folder. Options: -f, --folder DIRECTORY Target folder [required] -o, --output DIRECTORY Output folder [required] -n, --number INTEGER Amount [required] --prefix TEXT Rename copied file with prefix [default: case] -r, --rename Rename copied file --help Show this message and exit.","title":"RandomFileSelector"}]}